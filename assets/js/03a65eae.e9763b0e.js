"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[193],{3905:(e,t,o)=>{o.d(t,{Zo:()=>c,kt:()=>u});var s=o(7294);function r(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function n(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,s)}return o}function a(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?n(Object(o),!0).forEach((function(t){r(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):n(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function i(e,t){if(null==e)return{};var o,s,r=function(e,t){if(null==e)return{};var o,s,r={},n=Object.keys(e);for(s=0;s<n.length;s++)o=n[s],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(s=0;s<n.length;s++)o=n[s],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var l=s.createContext({}),d=function(e){var t=s.useContext(l),o=t;return e&&(o="function"==typeof e?e(t):a(a({},t),e)),o},c=function(e){var t=d(e.components);return s.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},p=s.forwardRef((function(e,t){var o=e.components,r=e.mdxType,n=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=d(o),u=r,m=p["".concat(l,".").concat(u)]||p[u]||h[u]||n;return o?s.createElement(m,a(a({ref:t},c),{},{components:o})):s.createElement(m,a({ref:t},c))}));function u(e,t){var o=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var n=o.length,a=new Array(n);a[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,a[1]=i;for(var d=2;d<n;d++)a[d]=o[d];return s.createElement.apply(null,a)}return s.createElement.apply(null,o)}p.displayName="MDXCreateElement"},3276:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>n,metadata:()=>i,toc:()=>d});var s=o(7462),r=(o(7294),o(3905));const n={id:"hostdash",title:"Host Dashboards / Monitors",description:"Host Level Dashboards and Monitors"},a="Host Dashboards and Monitors",i={unversionedId:"monitor/hostdash",id:"monitor/hostdash",title:"Host Dashboards / Monitors",description:"Host Level Dashboards and Monitors",source:"@site/docs/monitor/hostdash.md",sourceDirName:"monitor",slug:"/monitor/hostdash",permalink:"/docs/monitor/hostdash",draft:!1,editUrl:"https://github.com/gyeeta/gyeeta.github.io/tree/main/docs/monitor/hostdash.md",tags:[],version:"current",lastUpdatedAt:1674216155,formattedLastUpdatedAt:"Jan 20, 2023",frontMatter:{id:"hostdash",title:"Host Dashboards / Monitors",description:"Host Level Dashboards and Monitors"},sidebar:"docs",previous:{title:"Cluster Dashboard / Monitor",permalink:"/docs/monitor/clustdash"},next:{title:"Service Dashboards / Monitors",permalink:"/docs/monitor/servicedash"}},l={},d=[{value:"Host Dashboard",id:"host-dashboard",level:2},{value:"Host State Monitor",id:"host-state-monitor",level:2},{value:"Host CPU Memory Monitor",id:"host-cpu-memory-monitor",level:2},{value:"Host Network Flow Dashboard",id:"host-network-flow-dashboard",level:2}],c={toc:d};function h(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,s.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"host-dashboards-and-monitors"},"Host Dashboards and Monitors"),(0,r.kt)("h2",{id:"host-dashboard"},"Host Dashboard"),(0,r.kt)("p",null,"The Host Dashboard lists out all the currently active Hosts and shows their current state and various other statistics."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Host Dashboard",src:o(9720).Z,width:"1920",height:"947"})),(0,r.kt)("p",null,"The Host state is marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"Idle"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Good"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"OK"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Bad")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Severe")," depending on the number\nof Services and Processes that are in ",(0,r.kt)("inlineCode",{parentName:"p"},"Bad")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Severe")," state and depending on CPU and Memory status. "),(0,r.kt)("p",null,"This enables a quick evaluation of how all the hosts globally are performing and for any hosts with issues, further drilldown\nenables users to determine the processes or services of issue within that host."),(0,r.kt)("p",null,"The Host Dashboard also lists the Host level Contention (Delay) statistics for CPU, Memory and Disk IO. This allows a very quick\nway to figure out the hosts which are facing heavy CPU, Memory or IO contention or pressure."),(0,r.kt)("p",null,"The Host Dashboard is updated every 15 sec. "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"The backend servers update the Host state every 5 sec. The Dashboard just shows the state every 15 sec. The Host state can be queried using\nREST APIs using /v1/hoststate route.")),(0,r.kt)("h2",{id:"host-state-monitor"},"Host State Monitor"),(0,r.kt)("p",null,"The Host Monitor is used to graphically monitor the state of a specific Host either in real time or for historical time periods."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Host State Monitor",src:o(9592).Z,width:"1286",height:"949"})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Host State Monitor 2",src:o(9290).Z,width:"1920",height:"922"})),(0,r.kt)("p",null,"Using the Host monitor, users can drilldown charts after selecting the period of interest and get the precise Service/Processes which have issues.\nThe Host Monitor is updated every 5 sec."),(0,r.kt)("h2",{id:"host-cpu-memory-monitor"},"Host CPU Memory Monitor"),(0,r.kt)("p",null,"The Host CPU Memory Monitor graphically monitors the CPU and Memory related metrics of a specific Host in real time or for historical\ntime periods."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Host CPU Memory Monitor",src:o(7603).Z,width:"1156",height:"946"})),(0,r.kt)("p",null,"The Host CPU Memory Monitor is updated every 5 sec. Users can drilldown individual charts. For example if there is page swapping,\non drilldown, users can get processes on that host affected by Memory or disk IO delays, or processes that are marked ",(0,r.kt)("inlineCode",{parentName:"p"},"Bad")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Severe"),"\ndue to Memory issues."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"The Host CPU Memory state can be queried using REST APIs using /v1/cpumem route. The server updates the Host CPU Memory statistics\nevery 4 sec.")),(0,r.kt)("h2",{id:"host-network-flow-dashboard"},"Host Network Flow Dashboard"),(0,r.kt)("p",null,"The Host Network Flow Dashboard lists out all the currently active Network connections for the specific host."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Host Network Flow Dashboard",src:o(3650).Z,width:"1920",height:"949"})),(0,r.kt)("p",null,"The Host Network Flow Dashboard is updated every 20 sec. It shows all services / processes of the host with currently active network\nconnections, both within the host itself and external host connections as well. By default, all the Network Flow Dashboards show 3 tiers\nof connections : the central tier consisting of Services and Processes of the selected host, an upstream tier consisting of services which\nare called from the central tier clients and a downstream tier consisting of clients connecting to the central tier services."),(0,r.kt)("p",null,"Users can fetch data for further tiers by clicking on the ",(0,r.kt)("em",{parentName:"p"},"Get Next Upstream Tier")," or the ",(0,r.kt)("em",{parentName:"p"},"Get Next Downstream Tier")," buttons.\nClicking on any of the elements shown (for all tiers) will enable drilldown for further analysis."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"The backend servers update the Network Flows every 15 sec. The Flows are fetched in the UI using multiple REST API calls. The calls include\n/v1/extactiveconn, /v1/extclientconn and /v1/svcprocmap ")))}h.isMDXComponent=!0},7603:(e,t,o)=>{o.d(t,{Z:()=>s});const s=o.p+"assets/images/hostcpu-7652c3e45556a22a923fc8c2c126ded3.png"},9720:(e,t,o)=>{o.d(t,{Z:()=>s});const s=o.p+"assets/images/hostdash-aa82c5f812abab904f44c72aafbec0a4.png"},9592:(e,t,o)=>{o.d(t,{Z:()=>s});const s=o.p+"assets/images/hostmon-51bf2994e3eb890a095c8666f9b7d533.png"},9290:(e,t,o)=>{o.d(t,{Z:()=>s});const s=o.p+"assets/images/hostmon2-3a7eb74cd6247d07ae7e421ed3aef917.png"},3650:(e,t,o)=>{o.d(t,{Z:()=>s});const s=o.p+"assets/images/hostnet-7135cd5d01d40f92b4f02946efb1a63c.png"}}]);